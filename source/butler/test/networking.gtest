#pragma once

extern "C"
{
#include "networking.h"
}

#include <fstream>
#include <sstream>

#include "log.h"

using std::ifstream;
using std::stringstream;

void *receive_datagram_pthread(void *listener_input_pointer);
bool  start_listener_in_new_thread(int port, pthread_t *started, Datagram *expected);

struct ListenerInput
{
  PORT port;
  Datagram receive;
};

TEST(udp, send_and_receive)
{
  static const int port = 8080;

  // this buffer MUST contain a c-string
  char buffer[] = "this is some data";

  log("reading in the file...");
  Datagram to_send;
  to_send.data = buffer;
  to_send.length = sizeof(buffer);
  log("file contained |%s|!", buffer);

  log("starting to listen...");
  ListenerInput listener_input;
  listener_input.port = port;

  pthread_t listener_thread;
  if (pthread_create(&listener_thread, NULL, receive_datagram_pthread,
                     &listener_input) != 0
     )
    FAIL() << "Failed to send datagram!";

  log("listening!");

  // sleep to ensure (but not really...) that we start listening before we send
  // TODO: actually ensure this
  sleep(1);

  log("Sending the datagram...");
  if (!send_datagram(to_send, "127.0.0.1", port))
    FAIL() << "Failed to send datagram!";
  log("Sent!");

  log("Joining the thread...");
  if (pthread_join(listener_thread, NULL) != 0)
    FAIL() << "Failed to join the listener thread!";
  log("Thread joined!");

  ASSERT_STREQ(to_send.data, listener_input.receive.data);
}

void *receive_datagram_pthread(void *in)
{
  ListenerInput *input = static_cast<ListenerInput *>(in);
  log("passing in port %u", input->port);
  input->receive = receive_datagram(input->port);
  return NULL;
}

